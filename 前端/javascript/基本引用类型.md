*引用类型：把数据和功能组织到一起的结构*，注意：JS没有类和接口的概念。
对象是某个特定引用类型的实例。
新对象通过new操作符后跟一个构造函数。[创建对象的方式](obsidian://open?vault=my_ob&file=%E5%89%8D%E7%AB%AF%2Fjavascript%2F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F)
# Date
直接传入参数 年、*月（从0开始）*、日、24小时制、分钟、秒
```js
// 返回当前时间
let now = new Date();
// May 5, 2005 at 5:55:55 PM local time
let allFives = new Date(2005, 4, 5, 17, 55, 55);
```
# RegExp
正则表达式`let expression = /pattern/flags;`
- g：**全局模式**，查找字符串的全部内容，而不是只找到第一个就结束
- i：**不区分大小写**，忽略大小写
- m：**多行模式**，查找到第一行的末尾后继续查找
- y：**沾附模式**，表示从lastIndex开始及之后的字符串。
- u：Unicode模式
- s：dotAll模式，表示元字符`.`匹配任何字符

```js
// 字面量形式
let pattern1 = /[bc]at/i;
         
// 构造函数形式
let pattern2 = new RegExp("[bc]at", "i");
```
两者传入的都是字符串，因此有些时候需要**二次转义**。比如如果需要匹配`\`则要写成`\\`。
## 实例的方法
## `exec()`
配合捕获组使用。**需要设置g或者s否则每次只返回第一个匹配的子字符串**
输入：字符串
输出：
Array:没有匹配项的话返回null，否则返回包含**第一个匹配信息的数组**。
index:字符串中匹配模式的起始位置。
input:要查找的字符串。
```js
let text = "mom and dad and baby";
let pattern = /mom( and dad( and baby)?)?/gi;
         
let matches = pattern.exec(text);
console.log(matches.index);  // 0
console.log(matches.input);  // "mom and dad and baby"
console.log(matches[0]);     // "mom and dad and baby"
console.log(matches[1]);     // " and dad and baby"
console.log(matches[2]);     // " and baby"
```

# 原始值包装类型
# 单例内置对象